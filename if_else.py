# Сила прокрастинации

# Вася любит полениться. Особенно ему нравится, когда в году появляется такой лишний денёк, которого обычно не бывает. Напишите программу, которая поможет Васе определить, удастся ли ему побездельничать в определённом году или нет.
# Формат ввода

# Одно число — год.
# Формат вывода

# Одно слово «YES» (удастся) или «NO» (не удастся).


date = int(input())
if date % 4 == 0 and (date % 100 == 0 and date % 400) == 0:
    print("YES")
else:
    print("NO")


# А роза упала на лапу Азора

# Существуют такое интересное понятие как палиндром — число, слово, предложение и так далее, которое и слева-направо, и справа-налево читается одинаково.

# Напишите программу, которая проверяет, является ли число палиндромом.
# Формат ввода

# Одно четырёхзначное число
# Формат вывода

# YES если число является палиндромом, иначе — NO.


num = int(input())
if num // 100 // 10 == num % 100 % 10 and num % 100 // 10 == num // 100 % 10:
    print("YES")
else:
    print("NO")


# Лучшая защита — шифрование

# Коля испугался, что Аня подсмотрит все его пароли в блокноте, и решил их зашифровать. Для этого он берёт изначальный пароль — трёхзначное число — и по нему строит новое число по следующим правилам:

#     находится сумма цифр, стоящих в двух младших разрядах (десятки и единицы);
#     находится сумма цифр, стоящих в двух старших разрядах (сотни и десятки)
#     Эти две суммы, записанные друг за другом, в порядке не возрастания, формируют новое число.

# Помогите реализовать алгоритм шифрования.
# Формат ввода

# Одно трёхзначное число
# Формат вывода

# Результат шифрования


num = int(input())
num_ed = num % 10
num_de = (num // 10) % 10
num_sot = num // 100
if num_ed + num_de > num_de + num_sot:
    print(num_ed + num_de, num_de + num_sot, sep="")
else:
    print(num_de + num_sot, num_ed + num_de, sep="")


# Красота спасёт мир

# Одно из древних поверий гласит, что трёхзначное число красиво, если сумма его минимальной и максимальной цифр равна оставшейся цифре умноженной на 2.

# Напишите систему определяющую красоту числа.
# Формат ввода

# Одно трёхзначное число
# Формат вывода

# YES — если число красивое, иначе — NO


num = int(input())
b = list(map(int, str(num)))
b.sort()
if b[0] + b[2] == b[1] * 2:
    print("YES")
else:
    print("NO")



# Властелин Чисел: Братство общей цифры

# Во времена магии и драконов существовало мнение, что числа обладают великой силой, способной изменить мир.

# Всё началось с написания великих чисел. Три числа были переданы эльфам. Семь — отданы повелителям гномов. А девять... были переданы человеческому роду.

# Но все они оказались обмануты, потому что существовало ещё одно число. В стране Нумия на бумаге из тёмного папируса властелин Зерон тайно написал Единую Цифру, подчиняющую себе все великие числа.

# Давайте выясним, что это за цифра.
# Формат ввода

# В первой строке записано двузначное число одного из эльфов.
# Во второй строке — Гномов.
# В третьей — Людей.
# Формат вывода

# Одна цифра — общая у всех трёх чисел в одинаковой позиции


num_e, num_g, num_h = int(input()), int(input()), int(input())
num = [num_e, num_g, num_h]
b = []
c = []
for i in range(3):
    b.append(num[i] % 10)
    c.append(num[i] // 10)
if min(b) == max(b):
    print(b[0])
elif min(c) == max(c):
    print(c[0])


# Властелин Чисел: Две Башни

# Во времена, когда люди верили в великую силу чисел, оказалось, что волшебник Пифуман предал все народы и стал помогать Зерону.

# Чтобы посетить башни обоих злодеев одновременно, нам следует разделить магию числа, которое защищало нас в дороге.

# Чтобы поделить трёхзначное число, нам нужно составить из него минимально и максимально возможные двухзначные числа.
# Формат ввода

# Одно трёхзначное число.
# Формат вывода

# Два защитных числа для каждого отряда, записанные через пробел.


a = list(map(int, input()))
a.sort()
if int(str(a[1]) + str(a[0])) < int(str(a[0]) + str(a[1])) or a[0] == 0:
    print(f'{str(a[1]) + str(a[0])} {str(a[2]) + str(a[1])}')
else:
    print(f'{str(a[0]) + str(a[1])} {str(a[2]) + str(a[1])}')



# Властелин Чисел: Возвращение Цезаря

# До победы над злом остался один шаг — разрушить логово Зерона.

# Для этого нужно создать трёхзначное магическое число, которое будет сильнее двух двухзначных защитных чисел Зерона.

# Самый простой способ создать сильное число:

#     первой взять максимальную цифру из всех защитных чисел;
#     последней — минимальную;
#     в середину поставить сумму оставшихся без учёта переноса разряда.

# Помогите одолеть зло.
# Формат ввода

# В двух строках записаны защитные числа Зерона.
# Формат вывода

# Одно трёхзначное число, которое приведёт к победе.



numb = []
nums = [int(input()), int(input())]
for i in range(len(nums)):
    numb.append(nums[i] % 10)
    numb.append(nums[i] // 10)
numb.sort()
if numb[1] + numb[2] >= 10:
    print(f'{numb[3]}{(numb[1] + numb[2]) % 10}{numb[0]}')
else:
    print(f'{numb[3]}{numb[1] + numb[2]}{numb[0]}')



# Легенды велогонок возвращаются: кто быстрее?

# В новом сезоне за первенство в велогонках вновь борются лучшие из лучших. Протяжённость заключительной трассы — 43872м, и все хотят знать, кто получит золотую медаль.

# Нам известны средние скорости трёх претендентов на победу – Пети, Васи и Толи. Кто из них победит?
# Формат ввода

# В первой строке записана средняя скорость Пети.
# Во второй — Васи.
# В третьей — Толи.
# Формат вывода

# Красивый пьедестал (ширина ступеней 8 символов).
# Примечание

# В данный момент визуализация тестов работает некорректно.



speed = [int(input()), int(input()), int(input())]
name = ['Петя', 'Вася', 'Толя']
aver = 0
for i in range(len(name)):
    if i != speed.index(max(speed)) and i != speed.index(min(speed)):
        aver = i
print(f'{name[speed.index(max(speed))]: ^24}')
print(f'{name[aver]: ^8}')
print(f'{name[speed.index(min(speed))]: ^40}')
print(f"{'II': ^8}", end='')
print(f"{'I': ^8}", end='')
print(f"{'III': ^8}")



# Зайка — 2

# По пути домой родители вновь решили сыграть с детьми в поиск зверушек.
# Формат ввода

# Три строки описывающих придорожную местность.
# Формат вывода

# Строка в которой есть зайка, а затем её длина.
# Если таких строк несколько, выбрать ту, что меньше всех лексикографически.



txt = [input(), input(), input()]
sort = []
for i in range(len(txt)):
    if 'зайка' in txt[i]:
        sort.append(txt[i])

print(min(sort), len(min(sort)))